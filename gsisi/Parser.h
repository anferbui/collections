// Generated by Bisonc++ V2.4.8 on Mon, 10 Feb 2014 09:16:49 +0000

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "Parserbase.h"
#include "FlexLexer.h"
#include "Util.h"
#include <map>
#include <vector>
#include <cstdlib>
#include <algorithm>


#undef Parser

////////////////////////////////////////CLASSES//////////////////////////////////////////////


// class Name holds the information about each type name
// this consists of the name of the type and whether they are a pointer type
class Name {
public:
  Name(std::string n, bool ptr = false): name(n), isPointer(ptr){}

  std::string name;
  bool isPointer; // by default not a pointer
};

// class Type holds the information about each type
// this consists of the size of the type
// and the list of names that are all used to refer to that type
// this is used for typedef
class Type {
public:
  Type(std::string n, int s, bool ptr = false): size(s){
    names.push_back(Name(n, ptr));
  }
  std::vector<Name> names;
  int size;
};

// class DataInt is the basic data class that other classes inherits from
// consists of the type of the data, name of the data, whether the data is a pointer
// and what register the data is saved in

// it also has a virtual function str() that returns a string containing
// all important information about the data
class DataInt {
public:
  DataInt(std::string na="n/a", std::string t="n/a", int r=-1, bool ptr = false): isPointer(ptr), type(t), name(na), reg(r){}
  virtual std::string str(){
    std::string ptr = "";
    if(isPointer){ptr = "*";}
    return (type + ptr + " " + name);
  }

  std::string type; 
  std::string name;
  int reg; // // by default -1
  bool isPointer; // by default not a pointer
};

// class Var inherits from DataInt
// it has the added fields for whether the variable is currently in a register
// the label with which the variable has been saved into memory
// and the current value of the variable
class Var : public DataInt {
public:
  Var(std::string na="n/a", std::string t="n/a", int r=-1, std::string l = "", bool a = false, std::string v = "", bool re = true): 
  DataInt(na, t, r, a), lbl(l),val(v), inReg(re){}
  std::string lbl;
  std::string val;
  bool inReg;
};

// class Funct inherits from DataInt
// it has the added fields for whether the function has returned
// and a vector of DataInt* that makes up the arguments of the function
class Funct : public DataInt {
public:
  Funct(std::string na, std::string t, std::vector<DataInt*> ar, bool a = false, int r=-1)
  : DataInt(na, t,r,a), args(ar), hasReturned(false){}

  std::vector<DataInt*> args;
  bool hasReturned;

  virtual std::string str(){
   std::string str = type + " " + name + "(";
     std::vector<DataInt*>::iterator it;
     for(it = args.begin(); it != args.end(); ++it){
      str += " " + (*it)->type;
    }
    return str + ")";     
}
};


// class Struct inherits from DataInt
// it has the added fields for the size of the struct
// and a vector of DataInt* that makes up the members of the struct
class Struct : public DataInt {
public:
  Struct(std::string na, std::string t, std::vector<DataInt*> ar, int s = 0)
  : DataInt(na, t), mems(ar), size(s){}

  std::vector<DataInt*> mems;
  int size;

  virtual std::string str(){
   std::string str = type + " " + name + "(";
     std::vector<DataInt*>::iterator it;
     for(it = mems.begin(); it != mems.end(); ++it){
      str += " " + (*it)->type;
    }
    return str + ")";     
}
};


class Parser: public ParserBase
{  
public:
  Parser():ParserBase(),scope(0), currentFunc(NULL), lblc(0), lblcc(0),lbld(0), incl_Stdio(false), incl_Stdlib(false){
    // typel is a vector of class Types
    // when initialising we insert the basic C types into it
    typel.push_back(Type("int", 4));
    typel.push_back(Type("float",4));
    typel.push_back(Type("double",8));
    typel.push_back(Type("char", 1));

    // data is a vector of strings
    // that holds information about the ARM memory
    // and is appended to the end of the file
    data.push_back("");
    data.push_back("\t.data");
    data.push_back("");

    // initialises the registers to 0
    emptyRegisters();
  }


  int parse();
  void printC(); // prints the code into the standard output

private:

  bool incl_Stdio; // used to check whether stdio.h has been included
  bool incl_Stdlib; // used to check whether stdlib.h has been included

  std::vector<std::string> code; // holds ARM code
  std::vector<std::string> tcode; // holds temporary code to be implemented in a different position
                                  // such as the incrementing condition of a for loop
  std::vector<std::string> data; // holds ARM code for memory
  std::vector<std::vector<std::string>::iterator> pos; // holds the position in the vector code
                                                       // of the code to insert into tcode


// counters to keep track of labels
  int lblc;
  int lblcc;
  int lbld;

  yyFlexLexer lexer;

// multimap that contains all non-temp variables that have been declared
// where the key is the scope of the variable
// and the value is the variable itself
  std::multimap<int, DataInt*> varl;
  int scope; // holds the value of the current scope

  std::vector<DataInt*> stack; // used for function arguments
                              // everything still in the stack when a function has been called is seen as an argument to the function
  std::vector<Type> typel; // holds a list of all types and their sizes

  // An array of the registers
  // each holds a pointer to the variable currently stored there
  DataInt* regs[13]; 
  int regn; // Register number of the next free register

  std::vector<DataInt*> tempvar; // holds all temporary variables
  Funct* currentFunc; // pointer to the current function you're in, to keep track of returns
                      // if in main, value is NULL


        void extra();  // prints code from vector data
        void save_code(); // saves the code pos is pointing to into vector tcode

        void error(char const *msg);    // called on (syntax) errors
        void warning(char const *msg);  // same as error, but doesn't cause program to stop compilation
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();

        void printmap(std::multimap<int,DataInt*> mm); // prints a multimap
        void printscope(); // prints the current scope

        bool findvar(std::string id); // finds a variable in the whole of the map
                                      // except scope 0, which is reserved for functions and structs
        bool findvar(std::string id, int sc); // finds a variable in a certain scope

        void delete_lvl(std::multimap<int, DataInt*>& mm, int lvl); // deletes a level of the multimap
        void delete_map(std::multimap<int, DataInt*>& mm); // deletes a multimap

        // compares two types
        // taking into account the different names that maybe be used to refer to a type
        bool type_compare(std::string a, std::string b); 
        bool type_compare(int ra, int rb); // same as before but using the regs the variables are stored in
        bool type_check(std::string t); // checks whether a type exists
        std::string get_type(std::string id); // gets the type of a variable using its name
        std::string get_type(std::string id, int sc); // gets the type of a variable using its name and the scope it's in
        std::string get_type(int reg); // gets the type of a variable using its reg

        int get_reg(std::string id) ; // gets the register of a variable using its name
        int get_reg(std::string id, int sc); // same but in a certain scope

        int save_reg(DataInt* ptr); // saves a variable into the next free reg
        int save_reg(DataInt* ptr, int n); // saves a variable into a certain reg
        int nextFree(); // finds the next free register

        std::string use(); // takes out the last element of the vector of temp variables
        bool isPointer(int reg); // used for operations with pointers
                                 //  returns an error if variable is not a pointer
        int get_types(std::string type); // gets the type size of a variable
        bool type_isPointer(std::string type); // finds out if a type is by default a pointer type


       std::string get_lbl(int reg); // gets the label in memory of a variable
       std::string get_val(int reg); // gets the value of a variable

       std::string select_b(std::string str); // selects a branch condition
       std::string select_cond(std::string str); // selects a condition
       void emptyRegisters(); // empties all registers
       void saveRegisters(); // called when no free registers remain
       int getlbl_reg(std::string id); // gets the register a variable is saved in, knowing the label
       bool get_isPointer(int reg); // returns whether the variable is a pointer
       bool get_inReg(std::string id); // gets whether a variable is in a register or not
       void set_inReg(std::string id); // sets inReg
       int find_type(std::string a); // returns an index to the position of a type in the vector typel
       
       // shortcut to convert a string to int
       int c_int(std::string str){
        return convert<int>(str);
      }

  };


///////////////////////////////FUNCTION DEFINITIONS///////////////////////////////////////////

  inline std::string Parser::use(){
   std::string ret = "-1";
   std::vector<DataInt*>::iterator it = tempvar.end();
   it--;
   if(*it != 0){
     ret = convert<std::string>((*it)->reg);
   } else {
     error("Unexpected register error.");
   }

   tempvar.pop_back();
   return ret;
 }

// used for operations with pointers
// returns an error if variable is not a pointer
 inline bool Parser::isPointer(int reg){
   if(reg==-1){
     error("An unexpected register error occurred");
   }

   Var* temp = (Var*)regs[reg];
   if(temp->isPointer==true){
    return true;
  }
  error("Invalid operation, variable is not a pointer");
  return false;
}

// gets the size of a type
inline int Parser::get_types(std::string type){
  for(int j =0; j < typel.size(); j++){ // goes through all the members of typel
    for(int i =0; i < typel[j].names.size(); i++){ // goes through all the names of each member
      if(type == typel[j].names[i].name){ // if type is found
        return typel[j].size; // returns its size
      }
    }
  }

  error("Cannot get size of undefined type");
  return -1;
}

// gets whether a type is a pointer type
inline bool Parser::type_isPointer(std::string type){
  for(int j =0; j < typel.size(); j++){ // goes through all the members of typel
    for(int i =0; i < typel[j].names.size(); i++){ // goes through all the names of each member
      if(type == typel[j].names[i].name){ // if type is found
        return typel[j].names[i].isPointer; // returns isPointer
      }
    }
  }

  error("Cannot get size of undefined type");
  return -1;
}

// Knowing the register a variable is in, returns its label in memory
inline std::string Parser::get_lbl(int reg){
 if(reg==-1){
   error("An unexpected register error occurred");
 }
 Var* temp = (Var*)regs[reg];
 return temp->lbl;
}

// Knowing the register a variable is in, returns its value
inline std::string Parser::get_val(int reg){
 if(reg==-1){
   error("An unexpected register error occurred");
 }
 Var* temp = (Var*)regs[reg];
 return temp->val;
}

// Knowing the register a variable is in, returns whether it's a pointer
inline bool Parser::get_isPointer(int reg){
 if(reg==-1){
   error("An unexpected register error occurred");
 }
 Var* temp = (Var*) regs[reg];
 return temp->isPointer;
}

// Finds whether a variable is currently saved in a register
 inline bool Parser::get_inReg(std::string id){
  int sc = scope;
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;
  Var* temp;

  while (sc>0){
    ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
    for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
      temp = (Var*) (*it).second;
      if(temp->name == id){
        return temp->inReg;
      }
    }
    sc--;
  }

  error("Variable has not been declared");
  return false;
}

// Saves a variable that is not in a register anymore
// Into a register
inline void Parser::set_inReg(std::string id){
	if(regn==-1){
   error("An unexpected register error occurred");
  }

 int sc = scope;
 std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;
 Var* temp;

 while (sc>0){
  ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    temp = (Var*) (*it).second;
    if(temp->name == id){
      temp->inReg = true; // sets the flag that it's in a register
      temp->reg = regn; // changes the register value to the new one
      save_reg(temp); // saves the variable in a register the register
      return;
    }
  }
  sc--;
}

error("Variable has not been declared");
return;
}

// Gets the register that holds the address of a variable
// Knowing its label in memory
inline int Parser::getlbl_reg(std::string id){
  int sc = scope;
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  while (sc>0){
    ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
    for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
      Var* temp = (Var*) (*it).second;
      if(temp->lbl == id){
        return temp->reg;
      }
    }
    sc--;
  }
  error("Variable could not be found");
  return -1;
}

// Saves the code that pos is pointing to into tcode
inline void Parser::save_code(){
  std::vector<std::string>::iterator temp = ++pos.back(); // selects last element of pos
  std::vector<std::string>::iterator it;


  // finds pos in code
  for (it = code.begin(); it != code.end(); it++){
    if((*it) == (*temp)){
      temp = it;
    }
  }

  it = temp;

  // pushes back all code from that point on until the end into tcode
  for (temp; temp != code.end(); temp++){
    tcode.push_back(*temp);
  }

  // deletes it from code
  code.erase(it, code.end());
  // removes the last element of pos from pos
  pos.pop_back();

}


// Empties all registers, and resets regn to 4
inline void Parser::emptyRegisters(){
  for(int i=0; i<12; i++){
    regs[i] = 0;
  }

  regn = 4;
}

// Prints the code to the standard output
inline void Parser::printC(){
  std::cout << "\t.global main" << std::endl;
  for (std::vector<std::string>::iterator it = code.begin(); it != code.end(); ++it){
   if ((*it).find(":")!=-1){      
     std::cout << *it << std::endl; // if a label, don't tab
   } else {
     std::cout << "\t" << *it << std::endl; // if not a label, tab
   }
 }
 extra();
}

// Prints the code in vector data to the standard output
inline void Parser::extra(){
  std::cout << std::endl;
  for (std::vector<std::string>::iterator it = data.begin(); it != data.end(); ++it){
    std::cout << *it << std::endl;
  }
}


// Selects an ARM branch condition depending on the operator
// Branches should branch to the end of the loop if the condition is not fulfilled
// So this returns the opposite condition
inline std::string Parser::select_b(std::string str){
  if(str == "=="){
    return "BNE ";
  } else if(str== "<"){
    return "BGE ";
  } else if(str == ">"){
    return "BLE ";
  } else if(str == "<="){
    return "BGT ";
  } else if(str ==">=") {
    return "BLT ";
  } else if (str =="!=") {
    return "BEQ ";
  }else if(str==""){
    return "BNE ";
  }
}

// Selects an ARM condition depending on the operator
inline std::string Parser::select_cond(std::string str){
  if(str == "=="){
    return "EQ ";
  } else if(str== "<"){
    return "LT ";
  } else if(str == ">"){
    return "GT ";
  } else if(str == "<="){
    return "LE ";
  } else if(str ==">=") {
    return "GE ";
  } else if (str =="!=") {
    return "NE ";
  } else if(str==""){
    return "EQ ";
  }
}


// Clears from the registers values that are not in use anymore
inline void Parser::saveRegisters(){
  bool reduced = false;
  bool intemp, instack;
  for(int i=4; i<11; i++){
    intemp = false;
    instack = false;

    // If a value is currently being used as a temp variable, do not delete
    for (int j =0; j<tempvar.size(); j++){
     if(regs[i] != 0){
       if (tempvar[j]->name == (regs[i])->name){
         intemp = true;
       }
     }
   }

   // If a value is currently int the stack, do not delete
  for (int j =0; j<stack.size(); j++){
     if(regs[i] != 0){
       if (stack[j]->name == (regs[i])->name){
         instack = true;
       }
     }
   }  

   // If a value is not a temp var, not in stack, and not a declared variable, then delete
   if(regs[i] != 0){
     if(!intemp && !instack){
       if(!findvar(regs[i]->str())){
         Var* temp  = (Var*) regs[i];
         temp-> inReg = false;
         regs[i] = 0;
         reduced = true;
       }
     }
   }
 }

 // If after all this, no registers have been cleared
 // Clear them all, and set the flag that they are not currently in a register
 if(reduced == false){
  for(int i=4; i<11; i++){
    Var* temp = (Var*) regs[i];
    temp->inReg = false;
    regs[i] = 0;
  }
}
}

// Saves a variable into the next free register
inline int Parser::save_reg(DataInt* ptr){
    int i = regn;
    regs[regn] = ptr;

    int n = nextFree(); // find the next free register
    if(n==-1){ // if there is not a free register
      saveRegisters(); // free some registers
      regn = nextFree(); // and make regn the next free register
    } else {
      regn = n;
    } 

    return i; 
  }

// Finds the next member in the array of registers with nothing saved in it
  inline int Parser::nextFree(){
    for(int i=4; i<12; i++){
      if(regs[i]==0){
        return i;
      }
    }

    return -1;
  }

// Saves a variable into a register
  inline int Parser::save_reg(DataInt* ptr, int n){
    regs[n] = ptr;
  }

// Finds the position of a type inside the vector of types
  inline int Parser::find_type(std::string a){
    for(int j = 0; j<typel.size();j++){
      for(int i =0; i < typel[j].names.size(); i++){
        if(a == typel[j].names[i].name){
          return j;
        }
      }
    }
  }

// Compares two types, taking their names as arguments
  inline bool Parser::type_compare(std::string a, std::string b){
    int ta = find_type(a); // finds type a
    int tb = find_type(b); // finds type b

    // if they are both part of the same member of the vector of types (have the same index)
    // then they are both the same type
    if(ta == tb){
      return true;
    }

    error("Operating on invalid types");
    return false;

  }

  // Compares two types, taking their registers as arguments
  inline bool Parser::type_compare(int ra, int rb){
   if(ra==-1 || rb == -1){
     error("An unexpected register error occurred");
   }

   if(regs[ra]==0 || regs[rb] == 0){
     error("An unexpected register error occurred");
   } 

   // Used for functions that return void pointers, such as malloc
   // If one of the types is void, it is considered compatible with any type
   if(regs[ra]->type == "void" || regs[rb]->type == "void"){
     return true;
   }

   Var* a = (Var*)regs[ra];
   Var* b = (Var*)regs[rb];
   std::string str = "Invalid type usage, operand1 is " + a->str() + " and operand2 is " + b->str();;

   if(a->type!=""&&b->type!=""){ // if they are not empty strings

    if(a->isPointer != b->isPointer){ // if they are not both pointers, or the opposite, error
      str = "Pointer error: " + str;
      error(str.c_str());
      return false;
    }

    if(!type_compare(a->type,b->type)){ // if they are not the same type, warning
      str = "Type size discrepancy: "+ str;
      warning(str.c_str());
      return false;
    } 
    return true;
  } else {
    return false;
  }                   
}

// Checks whether a type exists
// If it doesn't, returns an error
inline bool Parser::type_check(std::string t){
  std::vector<Type>::iterator it = typel.begin();

  for(it; it!=typel.end();it++){ // goes through the vector of types
    for(int i =0; i < (*it).names.size(); i++){ // goes through all the names 
                                               // used to refer to the same type
      if(t == (*it).names[i].name){
        return true;
      }
    }
  }

  error("Invalid type, type does not exist");
  return false;
}

// Returns the type of a variable, given its name
// If variable has not been declared, it returns an error
inline std::string Parser::get_type(std::string id){
  int sc = scope;
  std::string type = "";
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  while (sc>0){
    ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
    for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
      if((*it).second->name == id){
        type = (*it).second->type;
        sc = 0;
      }
    }
    sc--;
  }
  if(type == ""){
    error("Variable has not been declared");
  }

  return type;
}

// Returns the type of a variable, given its register
inline std::string Parser::get_type(int reg){
	if(reg==-1){
   error("An unexpected register error occurred");
  }
 return regs[reg]->type;
}

// Returns the type of a variable, given its name
// If variable has not been declared, it returns an error
// Only searches in the given scope
inline std::string Parser::get_type(std::string id, int sc){
  std::string type = "";
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;


  ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    if((*it).second->name == id){
      type = (*it).second->type;
    }
  }
  if(type == ""){
    error("Variable has not been declared");
  }

  return type;

}

// Returns the register a variable is stored in
// If variable has not been declared, it returns an error
inline int Parser::get_reg(std::string id){
  int sc = scope;
  int reg = -1;
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  while (sc>0){
    ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
    for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
      if((*it).second->name == id){
        reg = (*it).second->reg;
        sc = 0;
      }
    }
    sc--;
  }
  if(reg==-1){
    error("Variable has not been declared");
  }

  return reg;
}

// Returns the register a variable is stored in
// If variable has not been declared, it returns an error
// Only searches in the given scope
inline int Parser::get_reg(std::string id, int sc){
  int reg = -1;
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;


  ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    if((*it).second->name == id){
      reg = (*it).second->reg;
    }
  }
  if(reg==-1){
    error("Variable has not been declared");
  }

  return reg;

}

// Prints a multimap
inline void Parser::printmap(std::multimap<int,DataInt*> mm){
  std::multimap<int,DataInt*>::iterator it;

  for (it=mm.begin(); it!=mm.end(); ++it)
    std::cout << (*it).first << " => " << (*it).second->str() << '\n';
}

// Deletes a multimap
inline void Parser::delete_map(std::multimap<int, DataInt*>& mm){
  std::multimap<int,DataInt*>::iterator it;
  for (it=mm.begin(); it!=mm.end(); ++it)
    delete (*it).second;

  mm.erase(mm.begin(), mm.end());
}

// Prints the current scope
inline void Parser::printscope(){
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;
  ret = varl.equal_range(scope); // finds the range of members in the map that have scope as key
  
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    std::cout << (*it).first << " => " << (*it).second->str() << '\n';
  }
}

// Checks whether a variable has been declared in any scope
// Except scope 0, which is reserved for functions
inline bool Parser::findvar(std::string id){
  int sc = scope;
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  while (sc>0){
    ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
    for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
      if((*it).second->str() == id){ // if they have the same type and name, it's the same variable
        return true;
      }
    }
    sc--;
  }

  return false;
}


// Checks whether a variable is in a certain scope
inline bool Parser::findvar(std::string id, int sc){
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  ret = varl.equal_range(sc); // finds the range of members in the map that have sc as key
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    if((*it).second->str() == id){ // if they have the same type and name, it's the same variable
      return true;
    }
  }

  return false;
}


// Deletes a level of the multimap
inline void Parser::delete_lvl(std::multimap<int, DataInt*>& mm, int lvl){
  std::pair <std::multimap<int, DataInt*>::iterator, std::multimap<int, DataInt*>::iterator> ret;

  ret = mm.equal_range(lvl); // finds the range of members in the map that have lvl as key
                             // this returns a pair, with its two components being iterators
                             // for the multimap
  for (std::multimap<int, DataInt*>::iterator it=ret.first; it!=ret.second; ++it){
    int tmp = (*it).second->reg;
    if(tmp != -1){
      regs[tmp] = 0; // if the variable is currently in a register, remove from register
    }
    delete it->second;
  }
  mm.erase(ret.first, ret.second); // delete the whole lvl

}

inline void Parser::error(char const *msg)
{
  std::cerr << "ERROR: Line " << lexer.lineno() << ": " << msg << std::endl;
  std::cerr << "Stopping compilation..." << std::endl;
  printC();// prints code acquired so far
  exit(EXIT_FAILURE); // stops compilation, returns error
}

inline void Parser::warning(char const *msg)
{
  std::cerr << "WARNING: Line " << lexer.lineno() << ": " << msg << std::endl;
}

// $insert lex
inline int Parser::lex(){
  return lexer.yylex();
}

inline void Parser::print()      // use d_token, d_loc
{
}


#endif
